/**
 * The option executes a kick generated by the WalkKickEngine.
 */
option(InWalkKick)
{
  auto getKickFootOffset = [this](float phase)
  {
    Vector3f positionOffset;
    Vector3f rotationOffset;
    theWalkKickGenerator.getState(std::min(theWalkGenerator.t / theWalkGenerator.stepDuration, 1.f),
                                  positionOffset, rotationOffset);
    return Pose3f(Rotation::AngleAxis::unpack(rotationOffset), positionOffset);
  };

  initial_state(init)
  {
    walkRequest = theMotionRequest.walkRequest;
    theWalkKickGenerator.start(walkRequest.walkKickRequest);

    transition
    {
      if(theWalkGenerator.t == 0)
      {
        if(theWalkKickGenerator.requiresPreStep && theWalkGenerator.isLeftPhase == leftPreStepPhase)
          goto preStep;
        else if(!theWalkKickGenerator.requiresPreStep && theWalkGenerator.isLeftPhase != leftPreStepPhase)
          goto kick;
      }
      goto wait;
    }
  }

  state(wait)
  {
    transition
    {
      if(theWalkGenerator.t == 0)
      {
        if(theWalkKickGenerator.requiresPreStep && theWalkGenerator.isLeftPhase == leftPreStepPhase)
          goto preStep;
        else if(!theWalkKickGenerator.requiresPreStep && theWalkGenerator.isLeftPhase != leftPreStepPhase)
          goto kick;
      }
    }
    action
    {
      updateWalkRequestWithoutKick();
      Walking();
    }
  }

  state(preStep)
  {
    transition
    {
      if(theWalkGenerator.t == 0)
        goto kick;
    }
    action
    {
      const Pose2f& stepSize = theWalkKickGenerator.preStepSize;
      walk(Pose2f(stepSize.rotation, stepSize.translation.x(), stepSize.translation.y()), WalkGenerator::stepSizeMode);
    }
  }

  target_state(kick)
  {
    action
    {
      const Pose2f& stepSize = theWalkKickGenerator.stepSize;
      walk(Pose2f(stepSize.rotation, stepSize.translation.x(), stepSize.translation.y()),
           WalkGenerator::stepSizeMode, getKickFootOffset);
    }
  }
}
